static void add_hex_terms_to_forces_stage_2(gauge_field_t smeared_force, double const rho, stout_notes_tuple *trace, gauge_field_t const V, gauge_field_t const U)
{
  su3 ALIGN t1;
  su3 ALIGN t2;
  su3 ALIGN C_der;
  
#pragma omp for private(t1, t2, C_der)
  for (unsigned int x = 0; x < VOLUME; ++x)
  {
    for (unsigned int mu = 0; mu < 4; ++mu)
    {
      /* t2 = Z * C */
      generic_staples(&t1, x, mu, U);
      _real_times_su3(t1, rho, t1);
      _su3_times_su3(t2, trace[x][mu].Z, t1);

      /* t1 = Sigma * V */
      _su3_times_su3(t1, trace[x][mu].Sigma, V[x][mu]);
           
      /* t1 = Sigma * V - Z * C */
      _su3_refac_acc(t1, -1.0, t2);

      /* smeared_force = U * (Sigma * V - Z * C) * U^\dagger */
      _su3_times_su3d(t2, t1, U[x][mu]);
      _su3_times_su3(smeared_force[x][mu], U[x][mu], t2);
      
      /* This completes the first half of our calculation -- note that smeared_force can be safely overwritten.
         The data it contained is encapsulated in trace->Sigma at this point. */    
      
      /* C = U \frac{\partial C}{\partial U} Z  */
      /* Six lines in the derivation document -- mirrored here */     
      
      _su3_zero(C_der);
      for (unsigned int nu = 0; nu < 4; ++nu)
      {
        if (mu != nu)
        {
          unsigned int xmnu = g_idn[x][nu];
          unsigned int xpnu = g_iup[x][nu];
          unsigned int xpmu = g_iup[x][mu];
          unsigned int xmnu_pmu = g_idn[ xpmu ][nu];
          /* Four of the lines are all multiplied by the same matrix eventually -- we can aggregate them first*/
          
          /* Line 1 */
          _su3d_times_su3(t1, U[g_iup[x][nu]][mu], trace[x][nu].Z);
          _su3_times_su3(t2, U[g_iup[x][mu]][nu], t1);

          /* Line 2 */
          _su3_times_su3(t1, trace[xmnu][mu].Z, U[xmnu][nu]);
          _su3d_times_su3_acc(t2, U[xmnu_pmu][nu], t1);

          /* Line 5 */
          _su3_times_su3d(t1, trace[xpnu][mu].Z, U[x][nu]);
          _su3_times_su3_acc(t2, U[xpmu][nu], t1);
          
          /* Line 6 */
          _su3d_times_su3(t1, U[g_idn[x][nu]][mu], U[xmnu][nu]);
          _su3_times_su3_acc(t2, trace[xmnu_pmu][nu].Z, t1);

          /* Now add the final multiplication from the left */
          _su3_times_su3_acc(C_der, U[x][mu], t2);
          
          /* The remaining lines are multiplied by the same matrix from the right, so we can aggregate them too */
          
          /* Line 3 */
          _su3_times_su3(t1, U[xmnu][mu], U[xmnu_pmu][nu]);
          _su3_times_su3(t2, trace[xmnu][nu].Z, t1);

          /* Line 4 */
          _su3_times_su3(t1, U[xpnu][mu], trace[xpmu][nu].Z);
          _su3_times_su3_acc(t2, U[x][nu], t1);
          
          /* Now we plug in the final multiplication and the sign, aggregating in C_der */
          _su3_times_su3d(t1, t2, U[x][mu]);
          _su3_refac_acc(C_der, -1.0, t1);
        }
      }

      /* Now add this second half of the calculation to the smeared forces and project back to the tangent space */
      _su3_refac_acc(smeared_force[x][mu], rho, C_der);
      project_traceless_antiherm(&smeared_force[x][mu]);
    }
  }
  
#pragma omp single
  exchange_gauge_field(&smeared_force);
}
