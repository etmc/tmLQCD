static void construct_intermediates(stout_notes_tuple *trace, gauge_field_t const V, gauge_field_t const U, gauge_field_t const smeared_force)
{
  _Complex double ALIGN mat_trace;
  su3 ALIGN t1;
  su3 ALIGN t2;
  
#pragma omp for private(mat_trace, t1, t2)
  for (unsigned int x = 0; x < VOLUME; ++x)
    for (unsigned int mu = 0; mu < 4; ++mu)
    {    
      /* A factor of V[x][mu] has to be taken out. This can't be done outside of the smearing loop, since there are projections involved at each step. */
      _su3d_times_su3(trace[x][mu].Sigma, V[x][mu], smeared_force[x][mu]);

      /* t2 == Tr[U * Sigma * B2] * A */
      _su3_times_su3(t1, trace[x][mu].Sigma, trace[x][mu].B2);
      _trace_su3_times_su3(mat_trace, U[x][mu], t1);
      _complex_times_su3(t2, mat_trace, trace[x][mu].A);
      
      /* Z == (Tr[U * Sigma * B1] + Tr[U * Sigma * B2] * A ) * A */
      _su3_times_su3(t1, trace[x][mu].Sigma, trace[x][mu].B1);
      _trace_su3_times_su3(mat_trace, U[x][mu], t1);
      _su3_add_equals_complex_identity(t2, mat_trace);
      _su3_times_su3(trace[x][mu].Z, t2, trace[x][mu].A);
      
      /* Z == (Tr[U * Sigma * B1] + Tr[U * Sigma * B2] * A ) * A  + f_1 * U * Sigma */
      _su3_times_su3(t1, U[x][mu], trace[x][mu].Sigma);
      _complex_times_su3(t2, trace[x][mu].f1, t1);
      _su3_plus_su3(trace[x][mu].Z, t2, trace[x][mu].Z);
      
      /* Z == (Tr[U * Sigma * B1] + Tr[U * Sigma * B2] * A ) * A  + f_1 * U * Sigma - i * f2 * U * Sigma * A */
      _su3_times_su3(t2, t1, trace[x][mu].A);
      _complex_times_su3(t2, trace[x][mu].f2, t2);
      _su3_plus_su3(trace[x][mu].Z, t2, trace[x][mu].Z);

      /* t1 == (Tr[U * Sigma * B1] + Tr[U * Sigma * B2] * A ) * A  + f_1 * U * Sigma + f2 * ( U * Sigma * A + A * U * Sigma ) */
      _su3_times_su3(t2, trace[x][mu].A, t1);
      _complex_times_su3(t2, trace[x][mu].f2, t2);
      _su3_plus_su3(t1, t2, trace[x][mu].Z);
      
      /* Z = U^\dagger * P_TA(t1) == Z */
      project_traceless_antiherm(&t1);
      _su3d_times_su3(trace[x][mu].Z, U[x][mu], t1);
    }
  
#pragma omp single
  generic_exchange(&trace, sizeof(stout_notes_tuple));
}
